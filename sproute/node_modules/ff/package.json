{
  "name": "ff",
  "version": "0.0.18",
  "description": "Concise, Powerful Asynchronous Flow Control in JavaScript",
  "engine": [
    "node >=0.2.0"
  ],
  "author": {
    "name": "Marcus Cavanaugh",
    "email": "m@mcav.com"
  },
  "contributors": [
    {
      "name": "Michael Henretty",
      "email": "michael.henretty@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/gameclosure/ff.git"
  },
  "devDependencies": {
    "mocha": "~1.3.0"
  },
  "scripts": {
    "test": "mocha -R spec -t 5000"
  },
  "main": "lib/ff",
  "readme": "# <img src=\"http://f.cl.ly/items/3K113g321o0n0W0Y0Z33/Fast%20Forward%20Icon%20in%2032x32%20px.png\" width=25 height=25> ff: Concise, Powerful Asynchronous JavaScript Flow Control\n\n***ff* simplifies the most common use cases for series, parallel, and\npromise utilities.** \n\n#### Installation\n\n- Node.JS: `npm install ff`\n- Browsers: Add `lib/ff.js` to your HTML page.\n\n## Table of Contents\n\n- [Intro](#intro)\n- **[API Documentation](#api-documentation)**\n- [Advanced Usage](#advanced-usage)\n- [Promise API](#promise-api-deferreds)\n- **[Quick Reference & Cheat Sheet](#quick-reference--cheat-sheet)**\n\n## Intro\n\nHere's a brief example that shows both serial and parallel steps:\n\n```javascript\nvar f = ff(this, function () {\n    fs.readFile(\"1.txt\", f());\n    fs.readFile(\"2.txt\", f());\n}, function (fileA, fileB) {\n    concatFiles(fileA, fileB, f());\n}, function (result) {\n    f(result.toUpperCase());\n}).cb(cb);\n```\n\nIt also supports promises, using the `ff.defer` function [[docs]](#promise-api-deferreds):\n\n```javascript\nvar f = ff.defer(this);\n\nf.success(function(result, result2) { });\nf.error(function (err) { });\n\nf(result, result2); // or f.fail(err);\n```\n\nA typical Express web handler looks like this. (Note that even if an\nexception gets thrown during one of these handlers, the .error()\nhandler will be called.\n\n```javascript\nfunction (req, res, next) {\n    var f = ff(function() {\n        authenticateUser(req, f());\n    }, function (user) {\n        f(user); // pass the user along synchronously\n        user.getFriends(f());\n    }, function (user, friends) {\n        res.json({ user: user, friends: friends });\n    }).error(next); // call next() *only* on error\n}\n```\n\n---\n\n# API Documentation\n\n## First, call `ff` and save its return value (as `f`, perhaps).\n\n#### `var f = ff([context], stepFunctions... )`\n    \nThe ``ff`` function takes a context and any number of\nfunctions, which we call \"steps\". Each step is run one at a time. Use\n`ff`'s return value (often called `f`) to create callbacks for any\nasync functions used in each step.\n\n## Second, use the returned `f` object inside each step function.\n\n**Within your step functions, pass `f()` as the callback parameter to\nany async function.** This reserves a \"slot\" in the next step's\nfunction arguments. For instance:\n\n```javascript\n\tfs.readFile(\"1.txt\", f()); // fs.readFile will use that as a callback.\n```\n\nMost often, that's all you'll need, but there are other ways to pass\ndata:\n\n```javascript\n\tf(data); // pass data synchronously to the next function\n\tfs.exists(\"1.txt\", f.slotPlain()); // fs.exists doesn't pass (err, result), just (result)\n\temitter.once(\"close\", f.wait()); // just wait for the \"close\" event\n```\n\n### All Methods on `f`:\n\n#### `f()`\n\nCalling `f()` reserves a slot in the next step's function arguments,\nand returns a callback that you should pass into an async function.\nThe async function should be called with an error as in `callback(err,\nresult)`.\n\n#### `f(arg1, arg2...)`\n\nIf you call `f` with arguments, those arguments will be passed into\nthe next step. This can be useful when you need to pass along a value\ndirectly to the next function synchronously.\n\n#### `f.wait()`\n\nSometimes you don't want to pass any arguments to the next function,\nbut you just want to wait until an async call completes successfully.\nThis behaves exactly like `f()`, handling errors, but no arguments are\npassed to the next step.\n\n#### `f.slotPlain()`\n\nThis is like `f()`, except that the resulting callback must *not*\naccept an error, as in `callback(result)`. Node's `fs.exists` doesn't\nreturn an error, for instance, and so you must use `f.slotPlain()` for\nits callback instead. (If you had used `f.slot()`, it would have\nthought `fs.exists` had passed an *error* as the first argument.\n\n#### `f.waitPlain()`\n\nSee `f.slotPlain()`. Like `f.wait()`, this does not pass any\narguments to the next step.\n\n#### `f.slotMulti(n)`\n\nLike `f()`, except that the resulting callback will pass `n` arguments\nto the next step instead of just one. For instance, calling `var cb =\nf.slotMulti(2)` followed by `cb(err, rsp, body)` would pass both `rsp`\nand `body` as two arguments to the next step.\n\n#### `f.group()`\n\nThis reserves exactly one slot in the next step, and returns a group\nobject that has all of the above methods. Anything you slot or pass\ninto the group gets passed into the next function's argument list *as\nan array*. (See the Groups example.)\n\n#### `f.succeed(successArgs...)`\n\nThis causes the chain of steps to end successfully (after you return\nfrom the current function). The result handlers (`.success()` and\n`.cb()`) will be called as soon as the current step returns. No other\nsteps will be executed afterward.\n\n#### `f.fail(err)`\n\nThis causes the chain of steps to end as though the given error had\noccurred (after you return from the current function). The result\nhandlers (`.error()` and `.cb()`) will be called as soon as the\ncurrent step returns. No other steps will be executed afterward.\n\n#### `f.next(fn)`\n\nYou can add additional steps after calling `ff()` using `f.next(fn)`.\nInternally, we pass the arguments through this function initially.\n\n#### `f.timeout(milliseconds)`\n\nSet a timeout; if the `ff` chain of steps do not finish after this\nmany milliseconds, fail with a timeout Error. Works with both deferred\nand normal `ff` steps.\n\n## Finally, remember to handle the result! (`.cb`, `.error`, `.success`)\n\nAfter you've called `ff()` with your steps, you'll want to handle the\nfinal result that gets passed down the end of the function. We often\ndo this like so:\n\n```javascript\nvar f = ff(\n   // steps here...\n).cb(cb);\n```\n\nThat final callback will be passed arguments node-style: `cb(err,\nresults...)`. (The number of arguments after `err` depends on how many\nslots you've passed from the last function in the chain.) This lets\nyou use ff within any part of your code without expecting any other\nfunction to know that `ff` exists in your own code.\n\nThere are three ways you can handle the final result (you can mix and\nmatch):\n\n#### `f.cb( function (err, results...) { } )`\n\nA `.cb()` result handler will *always* be called, whether or not an\nerror occurred. An error object will be passed first (null if there\nwas no error.)\n\n#### `f.success( function (results...) {} )`\n\nA `.success()` handler will *only* be called if no error occured.\nAdditionally, an error object will *not* be passed. Only results.\n\n#### `f.error( function (err) {} )`\n\nA `.error()` result handler will *only* be called if an error occured.\nIn this case, `err` will never be null. (If you're using Express,\noften we use `.error(next)` to propagate whenever we didn't reach a\ncall to `res.send()`.)\n\n**Always remember to add one of these result handlers after your\n`ff()` call, so that errors propagate!** You can add multiple result\nhandlers and they will all be called simultaneously. \n\n### Error Handling\n\nIf any function throws an exception, or an error gets passed to one of\nthe callbacks (as in `callback(err, result)`), the error will be\npropagated immediately to your result handlers (`.cb()` and\n`.error()`). If a result handler throws an exception, that exception\nwill bubble up into Node's `unhandledException` handler or the\nbrowser's developer console.\n\n---\n\n# Advanced Usage\n\n### Groups (for processing arrays)\n\nThe `f.group()` method reserves exactly one slot in the next step and\nreturns an object just like `f`. Anything you slot or pass into the\ngroup gets passed into the next function's argument list *as an\narray*. This is useful for processing arrays of items. Here's an example:\n\n```javascript\nvar allMyFiles = [\"one.txt\", \"two.txt\", \"three.txt\"];\n\nvar f = ff(function() {\n    var group = f.group();\n    allMyFiles.forEach(function (file) {\n        fs.readFile(file, group());\n    });\n}, function (allFiles) {\n    // allFiles is an array of 3 items (the contents of each file).\n    \n    // If any call had returned an err, this function would not be\n    // called, and the error would have been passed down to `cb`.\n}).cb(cb);\n```\n\n### Implementation Details\n\nThe following are equivalent:\n\n```javascript\nvar f = ff(this,\n\tone,\n\ttwo,\n).cb(three);\n```\n\n```javascript\nvar f = ff(this);\nf.next(one);\nf.next(two);\nf.cb(three);\n```\n\nError handling is actually quite simple: If an error occurs in any\nstep, it gets passed down, skipping over any `.next` handlers.\n\n---\n\n# Promise API (Deferreds)\n\nBecause of the implementation details we just described, `ff` doubles\nas a simple promise library using a very similar API. All you need to\nremember is to call `ff.defer()` instead of `ff()`.\n\n```javascript\nvar f = ff.defer(this);\n\n// set callbacks:\nf.success(function(result, result2) { });\nf.error(function (err) { });\n\n// now trigger the result:\nf(result, result2); // or f.fail(err);\n```\n\nTo trigger success or failure:\n\n```javascript\nf(arg1, arg2...) // success\nf.fail(err)      // failure\n```\n\nJust like with a regular `ff` call, you can attach `.success()`,\n`.error()`, and `.cb()` handlers. \n\nYou can also pass functions into the `ff.defer(...)` call, just like\nregular `ff`:\n\n```javascript\nvar f = ff.defer(function(result, text) {\n\t// do something with result\n}, function () {\n\t// ...etc...\n}).cb(cb);\n\n// now fire the result into the first step!\nf(result, \"something else\");\n```\n\nOnce your chain has succeeded or failed, future `.success()` and\n`.error()` handlers will remember the result and fire immediately. The\nresult is stored on `f.result` once available.\n\n---\n# Quick Reference / Cheat Sheet\n\nThe [API Documentation](#api-documentation) provides a much more thorough tutorial.\n\n#### Control Flow API Summary\n\n```javascript\n// Create a chain of steps with the `ff` function:\nvar f = ff(context, function () {\n\t// Within each method, use the `f` object.\n\t// Most common uses:\n\tf(arg1, arg2); // pass multiple arguments synchronously\n\tfs.readFile(\"file1.txt\", f());      // use f() for async callbacks\n\tfs.readFile(\"file2.txt\", f.wait()); // just wait for the result\n                                        // without putting it in args\n\t\t\t\t\t\t\t\t\t \n\t// To process arrays, use groups:\n\tvar group = f.group();\n\tallFiles.forEach(function (item) {   // use any `f` function on arrays\n\t    fs.readFile(item, group.slot()); // and the result gets stored as\n\t});                                  // an array in the next step\n\t\n\t// Less common uses for atypical functions\n\tfs.exists(\"file3.txt\", f.slotPlain()); // fs.exists doesn't pass an error\n\tfs.exists(\"file4.txt\", f.waitPlain()); // ditto, and I don't care if it fails\n\tvar cb = f.slotMulti(2); // slot and pass two arguments to the next function\n\t                         // for example, cb(null, 1, 2);\n\t\n\t// Aborting the chain of steps early:\n\tf.succeed(result1, ...); // after this function, skip the other steps\n\tf.fail(err);             // after this function, fail with this error\n\tf.timeout(200);\t\t\t // abort if it doesn't finish before 200 milliseconds\n}, function (arg1, arg2, file1, allFiles, file3Exists, multi1, multi2) {\n\t// Do something amazing here!\n}).cb(cb); // <-- usually you'll have someone else handle a (err, result...) callback\n\n// Don't forget result handlers (often chained to `ff` for conciseness)\nf.cb(function (err, args...) { }); // triggered on both success and error\nf.success(function (args...) { }); // only on success\nf.error(function (err) { });       // only on error\n```\n\n#### Promise API Summary\n\n```javascript\n// Create a deferred\nvar f = ff.defer(context);\n// Add result handlers:\nf.success(function (args...) { });\nf.error(function (err) { });\nf.cb(function (err, args...) { }); // triggered on both success and error\n// Trigger results: \nf(arg1, ...); // success\nf.fail(err);  // failure\n// Add a timeout (which would result in a failure with a timeout Error\nf.timeout(milliseconds);\n// Get the result synchronously, if available (the error argument is on f.result[0])\nvar resultArray = f.result\n```\n\n---\n# Acknowledgements\n\nMade by [Marcus Cavanaugh](http://mcav.com/) and [Michael Henretty](http://twitter.com/mikehenrty).\n\nThis code was originally based on\n[Tim Caswell](mailto:tim@creationix.com)'s sketch of a\n[reimagined](https://gist.github.com/1524578) [Step](https://github.com/creationix/step) library.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/gameclosure/ff/issues"
  },
  "_id": "ff@0.0.18",
  "dist": {
    "shasum": "728f4af0993ecc4292bc028f6ecf03064d340ff0"
  },
  "_from": "ff@0.0.18",
  "_resolved": "https://registry.npmjs.org/ff/-/ff-0.0.18.tgz"
}
